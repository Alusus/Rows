@merge module Rows {
    macro define_model_essentials {
        def db: ref[Db];
        db~ptr = 0;
        handler this.save() {
            if this.db~ptr != 0 Rows.Query[this_type](this.db).save(this);
        }
        handler this.delete() {
            if this.db~ptr != 0 Rows.Query[this_type](this.db).delete(this);
        }
    }

    def infixOperators: Map[String, String];
    infixOperators.{
        this(String("==")) = "=";
        this(String("!=")) = "!=";
        this(String(">")) = ">";
        this(String(">=")) = ">=";
        this(String("<")) = "<";
        this(String("<=")) = "<=";
        this(String("and")) = "&&";
        this(String("&&")) = "&&";
        this(String("or")) = "||";
        this(String("||")) = "&&";
    };

    func generateWhere (obj: ref[TiObject]): TioSrdRef {
        def result: TioSrdRef;
        def result2: TioSrdRef;
        def resultArray: Array[TioSrdRef];

        if obj~ptr == 0 {
            System.fail(1, "generateWhere: obj is null.\n");
        }

        if isDerivedFrom[obj, PrefixOperator] {
            def binding: ref[Binding](getInterface[obj, Binding]);
            def operator: String = castRef[binding.getMember("type"), TiStr].value;
            if operator != "not" and operator != "!" {
                System.fail(1, String("generateWhere error: Invalid PrefixOperator ") + operator + "\n");
            }
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            if !Spp.astMgr.buildAst(
                ast { String("NOT ") + (cond) },
                Map[String, ref[TiObject]]()
                    .set(String("cond"), generateWhere(mapContaining.getElement(0)).obj),
                result2
            ) {
                System.fail(1, "generateWhere/Bracket: error\n");
            }
            return result2
        } else if isDerivedFrom[obj, ComparisonOperator] or isDerivedFrom[obj, AssignmentOperator] {
            def binding: ref[Binding](getInterface[obj, Binding]);
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            def operator: String = castRef[binding.getMember("type"), TiStr].value;
            if infixOperators(operator) == "" {
                System.fail(1, String("generateWhere error: Invalid InfixOperator ") + operator + "\n");
            } else {
                operator = infixOperators(operator);
            }
            if !Spp.astMgr.buildAst(
                ast {
                    String("\"") + _this.getColumnNameForVar(String("{{name}}")) + "\"" +
                    String(" {{op}} '") +
                    _this.validationBuffer.name~use_in(_buffer) no_injection { _buffer = val } +
                    String("'")
                },
                Map[String, ref[TiObject]]()
                    .set(String("name"), mapContaining.getElement("first"))
                    .set(String("op"), TiStr(operator))
                    .set(String("val"), mapContaining.getElement("second")),
                result
            ) {
                System.fail(1, "generateWhere error: building InfixOperator failed.\n");
            }
        } else if isDerivedFrom[obj, LogOperator] {
            def binding: ref[Binding](getInterface[obj, Binding]);
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            if !Spp.astMgr.buildAst(
                ast { (cond1) + String(" {{op}} ") + (cond2) },
                Map[String, ref[TiObject]]()
                    .set(String("cond1"), generateWhere(mapContaining.getElement("first")).obj)
                    .set(String("op"), binding.getMember("type"))
                    .set(String("cond2"), generateWhere(mapContaining.getElement("second")).obj),
                result
            ) {
                System.fail(1, "generateWhere/LogOperator: error\n");
            }
        } else if isDerivedFrom[obj, Bracket] {
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            if !Spp.astMgr.buildAst(
                ast { String("(") + (cond) + String(")") },
                Map[String, ref[TiObject]]()
                   .set(String("cond"), generateWhere(mapContaining.getElement("operand")).obj),
                result
            ) {
                System.fail(1, "generateWhere/Bracket: error\n");
            }
        } else if isDerivedFrom[obj, LinkOperator] {
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            def binding: ref[Binding](getInterface[obj, Binding]);
            def mapContaining2: ref[MapContaining](getInterface[mapContaining.getElement("second"), MapContaining]);
            def containing: ref[Containing](getInterface[mapContaining2.getElement("operand"), Containing]);
            def i: int =0;

            if !Spp.astMgr.buildAst(
                ast {
                    String("\"") + _this.getColumnNameForVar(String("{{name}}")) + "\"" +
                    String(" in (")
                },
                Map[String, ref[TiObject]]().set(String("name"),mapContaining.getElement("first")),
                result2
            ) {
                System.fail(1, "generateWhere/Bracket: error\n");
            }

            resultArray.add(result2);
            for i=0 , i < containing.getElementCount()~cast[Int]-1 , i = i+1 {
                if !Spp.astMgr.buildAst(
                    ast {
                        result + (
                            String("'" ) +
                            _this.validationBuffer.name~use_in(_buffer) no_injection { _buffer = val } +
                            String("' , ")
                        )
                    },
                    Map[String, ref[TiObject]]()
                        .set(String("name"), mapContaining.getElement("first"))
                        .set(String("val"), containing.getElement(i))
                        .set(String("result"), resultArray(i)),
                    result2
                ) {
                    System.fail(1, "generateWhere/Bracket: error\n");
                }
                resultArray.add(result2);
            }
            if !Spp.astMgr.buildAst(
                ast {
                    result + (
                        String("'" ) +
                        _this.validationBuffer.name~use_in(_buffer) no_injection { _buffer = val } +
                        String("')")
                    )
                },
                Map[String, ref[TiObject]]()
                    .set(String("name"), mapContaining.getElement("first"))
                    .set(String("val"), containing.getElement(containing.getElementCount()~cast[Int]-1))
                    .set(String("result"), resultArray(resultArray.getLength()-1)),
                result
            ) {
                System.fail(1, "generateWhere/Bracket: error\n");
            }
        } else {
            def binding: ref[Binding](getInterface[obj, Binding]);
            if !Spp.astMgr.buildAst(
                ast { String("bye") },
                Map[String, ref[TiObject]]().set(String("op"), binding.getMember("type")),
                result
            ) {
                System.fail(1, "Failed to build condition.\n");
            }
        }
        return result;
    }

    func generateOrder (obj: ref[TiObject]): TioSrdRef {
        def result: TioSrdRef;

        if obj~ptr == 0 {
            System.fail(1, "generateOrder: obj is null.\n");
        }
        if isDerivedFrom[obj, Identifier] {
            if !Spp.astMgr.buildAst(
                ast {
                    this.ordering.add(this.getColumnNameForVar(String("{{column}}")));
                    this.validationBuffer.column;
                },
                Map[String, ref[TiObject]]().set(String("column"), obj),
                result
            ) {
                System.fail(1, "generateOrder error - building Identifier failed.\n");
            }
        } else if isDerivedFrom[obj, PrefixOperator] {
            def binding: ref[Binding](getInterface[obj, Binding]);
            def operator: String = castRef[binding.getMember("type"), TiStr].value;
            if operator != "-" {
                System.fail(1, String("generateOrder error: Invalid PrefixOperator ") + operator + "\n");
            }
            def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
            obj~no_deref = mapContaining.getElement(0);
            if !isDerivedFrom[obj, Identifier] {
                System.fail(1, String("generateOrder error: Invalid PrefixOperator operand type,\n"));
            }
            if !Spp.astMgr.buildAst(
                ast {
                    this.ordering.add(String("-") + this.getColumnNameForVar(String("{{column}}")));
                    this.validationBuffer.column;
                },
                Map[String, ref[TiObject]]().set(String("column"), obj),
                result
            ) {
                System.fail(1, "generateOrder error - building Identifier failed.\n");
            }
        } else if isDerivedFrom[obj, Bracket] {
            def mapContainer: MapContainerOf[obj];
            result = generateOrder(mapContainer.getElement("operand"));
        } else if isDerivedFrom[obj, Core.Data.Ast.List] {
            def container: ContainerOf[obj];
            result = generateOrder(container.getElement(0));
            def i: Int;
            for i = 1, i < container.getElementCount()~cast[Int], ++i {
                def combinedResult: TioSrdRef;
                if !Spp.astMgr.buildAst(
                    ast { prevResult; result; },
                    Map[String, ref[TiObject]]()
                        .set(String("prevResult"), result)
                        .set(String("result"), generateOrder(container.getElement(i))),
                    combinedResult
                ) {
                    System.fail(1, "generateOrder error - building List failed.\n");
                }
                result = combinedResult;
            }
        } else {
            System.fail(1, "generateOrder error - unexpected AST object type.\n");
        }
        return result;
    }

    func generateUpdate (obj: ref[TiObject]): TioSrdRef {
        def result: TioSrdRef;

        if obj~ptr == 0 {
            System.fail(1, "generateUpdate: obj is null.\n");
        }
        if isDerivedFrom[obj, AssignmentOperator] {
            def binding: ref[Binding](getInterface[obj, Binding]);
            def opType: String = castRef[binding.getMember("type"), Core.Basic.TiStr].value;
            if opType == "=" {
                def mapContainer: MapContainerOf[obj];
                if !Spp.astMgr.buildAst(
                    ast {
                        columns.add(_this.getColumnNameForVar(String("{{name}}")));
                        _this.validationBuffer.name = val;
                        data.add(String() + _this.validationBuffer.name);
                    },
                    Map[String, ref[TiObject]]()
                        .set(String("name"), mapContainer.getElement("first"))
                        .set(String("val"), mapContainer.getElement("second")),
                    result
                ) {
                    System.fail(1, "generateUpdate error - building AssignmentOperator failed.\n");
                }
            } else {
                System.fail(1, String("generateUpdate error - Invalid AssignmentOperator type: ") + opType + "\n");
            }
        } else if isDerivedFrom[obj, Bracket] {
            def mapContainer: MapContainerOf[obj];
            result = generateUpdate(mapContainer.getElement("operand"));
        } else if isDerivedFrom[obj, Core.Data.Ast.List] {
            def container: ContainerOf[obj];
            result = generateUpdate(container.getElement(0));
            def i: Int;
            for i = 1, i < container.getElementCount()~cast[Int], ++i {
                def combinedResult: TioSrdRef;
                if !Spp.astMgr.buildAst(
                    ast { prevResult; result; },
                    Map[String, ref[TiObject]]()
                        .set(String("prevResult"), result)
                        .set(String("result"), generateUpdate(container.getElement(i))),
                    combinedResult
                ) {
                    System.fail(1, "generateUpdate error - building List failed.\n");
                }
                result = combinedResult;
            }
        } else {
            System.fail(1, "generateUpdate error - unexpected AST object type.\n");
        }
        return result;
    }

    func generateParsing (varArray: Array[String], typeArray: Array[ref[Spp.Ast.Type]]) {
        @shared def strType: ref[Spp.Ast.Type](Spp.astMgr.traceType(ast Root.Srl.String));
        def i: Int;
        for i = 0, i < typeArray.getLength(), i = i+1 {
            if typeArray(i)~ptr == strType~ptr {
                if !Spp.astMgr.insertAst(
                    (ast model.strVal = data(j)),
                    Map[String, ref[TiObject]]()
                        .set(String("j"), Core.Data.Ast.IntegerLiteral(String("") + i))
                        .set(String("strVal"), Core.Data.Ast.Identifier(varArray(i)))
                ) {
                    System.fail(1, "generateParsing error: inserting AST failed.\n");
                }
            } else if typeArray(i).getMyTypeInfo().typeName == "IntegerType" {
                if !Spp.astMgr.insertAst(
                    (ast model.intVal = parseInt(data(j).buf)),
                    Map[String, ref[TiObject]]()
                        .set(String("j"), Core.Data.Ast.IntegerLiteral(String("") + i))
                        .set(String("intVal"), Core.Data.Ast.Identifier(varArray(i)))
                ) {
                    System.fail(1, "generateParsing error: inserting AST failed.\n");
                }
            } else if typeArray(i).getMyTypeInfo().typeName == "FloatType" {
                if !Spp.astMgr.insertAst(
                    (ast model.floatVal = parseFloat(data(j).buf)),
                    Map[String, ref[TiObject]]()
                        .set(String("j"), Core.Data.Ast.IntegerLiteral(String("") + i))
                        .set(String("floatVal"), Core.Data.Ast.Identifier(varArray(i)))
                ) {
                    System.fail(1, "generateParsing error: inserting AST failed.\n");
                }
            }
        }
    }

    func generateGetData (varArray: Array[String]) {
        def i: Int;
        for i = 0, i < varArray.getLength(), i = i+1 {
            if !Spp.astMgr.insertAst(
                (ast data.add(String() + model.varName)),
                Map[String, ref[TiObject]]().set(String("varName"), Core.Data.Ast.Identifier(varArray(i)))
            ) {
                System.fail(1, "generateGetData error: inserting AST failed.\n");
            }
        }
    }

    func generateTableName (classAst: ref[Core.Basic.TiObject]) {
        def params: Array[String] = getElementModifierParams(classAst, "model");
        if params.getLength() != 1 {
            System.fail(1, "generateTableName - Invalid model: Missing or invalid @model modifier.");
        }
        Spp.astMgr.insertAst(
            (ast Srl.String("{{className}}")),
            Srl.Map[Srl.String, ref[Core.Basic.TiObject]]().set(Srl.String("className"), TiStr(params(0)))
        );
    }
}

